"""Module for typing information from typing and typing_extensions."""

import sys

__all__: list[str] = []
_typing = __import__(name="typing")
_typing_extensions = __import__(name="typing_extensions")
for singleattr in [item for item in dir(_typing) if not item.startswith("_")]:
    # print(singleattr) ==> logging?
    sys._getframe(0).f_globals[singleattr] = getattr(
        __import__(name="typing"),
        singleattr,
    )
    __all__.append(singleattr)  # pyright: ignore[reportUnsupportedDunderAll]
#    for singleattr in [item for item in dir(_typing_extensions) if item not in dir(_typing)]:
for singleattr in [
    item
    for item in dir(_typing_extensions)
    if item not in dir(_typing) and not item.startswith("_")
]:
    # print(singleattr) ==> logging?
    sys._getframe(0).f_globals[singleattr] = getattr(
        __import__(name="typing_extensions"),
        singleattr,
    )
    __all__.append(singleattr)  # pyright: ignore[reportUnsupportedDunderAll]


class KwargsForPrint(TypedDict, total=False):  # type: ignore[name-defined,call-arg]  # noqa: F821
    """Class for Type Checking Kwargs 2 Print"""

    sep: str
    end: str
    file: IO[str]  # type: ignore[name-defined]  # noqa: F821
    flush: bool


# for python<=3.5,2.7
# https://typing.python.org/en/latest/...
# ...spec/typeddict.html#alternative-syntax
# KwargsForPrint = TypedDict(  # noqa: F405
#    "KwargsForPrint",
#    {"sep": str, "end": str, "file": IO[str], "flush": bool},  # noqa: F405
#    total=False,
# )

""" easy = False

if easy:
    # prefilled from python 3.14.3
    typingcontents = (
        "ABCMeta",
        "AbstractSet",
        "Annotated",
        "Any",
        "AnyStr",
        "AsyncContextManager",
        "AsyncGenerator",
        "AsyncIterable",
        "AsyncIterator",
        "Awaitable",
        "BinaryIO",
        "ByteString",
        "CT_co",
        "Callable",
        "ChainMap",
        "ClassVar",
        "Collection",
        "Concatenate",
        "Container",
        "ContextManager",
        "Coroutine",
        "Counter",
        "DefaultDict",
        "Deque",
        "Dict",
        "EXCLUDED_ATTRIBUTES",
        "Final",
        "ForwardRef",
        "FrozenSet",
        "Generator",
        "Generic",
        "GenericAlias",
        "Hashable",
        "IO",
        "ItemsView",
        "Iterable",
        "Iterator",
        "KT",
        "KeysView",
        "List",
        "Literal",
        "LiteralString",
        "Mapping",
        "MappingView",
        "Match",
        "MutableMapping",
        "MutableSequence",
        "MutableSet",
        "NamedTuple",
        "NamedTupleMeta",
        "Never",
        "NewType",
        "NoDefault",
        "NoReturn",
        "NotRequired",
        "Optional",
        "OrderedDict",
        "ParamSpec",
        "ParamSpecArgs",
        "ParamSpecKwargs",
        "Pattern",
        "Protocol",
        "ReadOnly",
        "Required",
        "Reversible",
        "Self",
        "Sequence",
        "Set",
        "Sized",
        "SupportsAbs",
        "SupportsBytes",
        "SupportsComplex",
        "SupportsFloat",
        "SupportsIndex",
        "SupportsInt",
        "SupportsRound",
        "T",
        "TYPE_CHECKING",
        "T_co",
        "T_contra",
        "Text",
        "TextIO",
        "Tuple",
        "Type",
        "TypeAlias",
        "TypeAliasType",
        "TypeGuard",
        "TypeIs",
        "TypeVar",
        "TypeVarTuple",
        "TypedDict",
        "Union",
        "Unpack",
        "VT",
        "VT_co",
        "V_co",
        "ValuesView",
        "_ASSERT_NEVER_REPR_MAX_LENGTH",
        "_AnnotatedAlias",
        "_AnyMeta",
        "_BaseGenericAlias",
        "_CallableGenericAlias",
        "_CallableType",
        "_ConcatenateGenericAlias",
        "_DeprecatedGenericAlias",
        "_Final",
        "_Func",
        "_GenericAlias",
        "_IdentityCallable",
        "_LazyAnnotationLib",
        "_LiteralGenericAlias",
        "_NamedTuple",
        "_NotIterable",
        "_PROTO_ALLOWLIST",
        "_ProtocolMeta",
        "_SPECIAL_NAMES",
        "_Sentinel",
        "_SpecialForm",
        "_SpecialGenericAlias",
        "_TYPING_INTERNALS",
        "_TupleType",
        "_TypedCacheSpecialForm",
        "_TypedDict",
        "_TypedDictMeta",
        "_TypingEllipsis",
        "_UnionGenericAlias",
        "_UnionGenericAliasMeta",
        "_UnpackGenericAlias",
        "__all__",
        "__builtins__",
        "__cached__",
        "__doc__",
        "__file__",
        "__getattr__",
        "__loader__",
        "__name__",
        "__package__",
        "__spec__",
        "_abc_instancecheck",
        "_abc_subclasscheck",
        "_add_type_params_to_scope",
        "_alias",
        "_allow_reckless_class_checks",
        "_caches",
        "_caller",
        "_check_generic_specialization",
        "_cleanups",
        "_collect_type_parameters",
        "_deduplicate",
        "_deprecation_warning_for_no_type_params_passed",
        "_eval_type",
        "_flatten_literal_params",
        "_generic_class_getitem",
        "_generic_init_subclass",
        "_get_protocol_attrs",
        "_get_typeddict_qualifiers",
        "_idfunc",
        "_is_dunder",
        "_is_param_expr",
        "_is_typevar_like",
        "_is_unpacked_typevartuple",
        "_lazy_annotationlib",
        "_lazy_load_getattr_static",
        "_make_eager_annotate",
        "_make_forward_ref",
        "_make_nmtuple",
        "_namedtuple_mro_entries",
        "_no_init_or_replace_init",
        "_overload_dummy",
        "_overload_registry",
        "_paramspec_prepare_subst",
        "_paramspec_subst",
        "_prohibited",
        "_proto_hook",
        "_sentinel",
        "_should_unflatten_callable_args",
        "_special",
        "_strip_annotations",
        "_tp_cache",
        "_type_check",
        "_type_check_issubclass_arg_1",
        "_type_convert",
        "_type_repr",
        "_typevar_subst",
        "_typevartuple_prepare_subst",
        "_unpack_args",
        "_value_and_type_iter",
        "abstractmethod",
        "assert_never",
        "assert_type",
        "cast",
        "clear_overloads",
        "collections",
        "copyreg",
        "dataclass_transform",
        "defaultdict",
        "evaluate_forward_ref",
        "final",
        "functools",
        "get_args",
        "get_origin",
        "get_overloads",
        "get_protocol_members",
        "get_type_hints",
        "is_protocol",
        "is_typeddict",
        "no_type_check",
        "no_type_check_decorator",
        "operator",
        "overload",
        "override",
        "reveal_type",
        "runtime_checkable",
        "sys",
        "types",
    )
    typingextensionscontents = (
        "AbstractSet",
        "Annotated",
        "Any",
        "AnyStr",
        "AsyncContextManager",
        "AsyncGenerator",
        "AsyncIterable",
        "AsyncIterator",
        "Awaitable",
        "BinaryIO",
        "Buffer",
        "Callable",
        "CapsuleType",
        "ChainMap",
        "ClassVar",
        "Collection",
        "Concatenate",
        "Container",
        "ContextManager",
        "Coroutine",
        "Counter",
        "DefaultDict",
        "Deque",
        "Dict",
        "Doc",
        "Final",
        "Format",
        "ForwardRef",
        "FrozenSet",
        "Generator",
        "Generic",
        "GenericMeta",
        "Hashable",
        "IO",
        "IntVar",
        "ItemsView",
        "Iterable",
        "Iterator",
        "KT",
        "KeysView",
        "List",
        "Literal",
        "LiteralString",
        "Mapping",
        "MappingView",
        "Match",
        "MutableMapping",
        "MutableSequence",
        "MutableSet",
        "NamedTuple",
        "Never",
        "NewType",
        "NoDefault",
        "NoExtraItems",
        "NoReturn",
        "NotRequired",
        "Optional",
        "OrderedDict",
        "PEP_560",
        "ParamSpec",
        "ParamSpecArgs",
        "ParamSpecKwargs",
        "Pattern",
        "Protocol",
        "ReadOnly",
        "Reader",
        "Required",
        "Reversible",
        "Self",
        "Sentinel",
        "Sequence",
        "Set",
        "Sized",
        "SupportsAbs",
        "SupportsBytes",
        "SupportsComplex",
        "SupportsFloat",
        "SupportsIndex",
        "SupportsInt",
        "SupportsRound",
        "T",
        "TYPE_CHECKING",
        "T_co",
        "T_contra",
        "Text",
        "TextIO",
        "Tuple",
        "Type",
        "TypeAlias",
        "TypeAliasType",
        "TypeForm",
        "TypeGuard",
        "TypeIs",
        "TypeVar",
        "TypeVarTuple",
        "TypedDict",
        "Union",
        "Unpack",
        "VT",
        "ValuesView",
        "Writer",
        "_ASSERT_NEVER_REPR_MAX_LENGTH",
        "_AnnotatedAlias",
        "_CapsuleType",
        "_ConcatenateGenericAlias",
        "_DefaultMixin",
        "_EXCLUDED_ATTRS",
        "_EllipsisDummy",
        "_ExtensionsSpecialForm",
        "_FORWARD_REF_HAS_CLASS",
        "_NEEDS_SINGLETONMETA",
        "_PEP_696_IMPLEMENTED",
        "_PEP_728_IMPLEMENTED",
        "_PROTO_ALLOWLIST",
        "_Sentinel",
        "_SpecialForm",
        "_TAKES_MODULE",
        "_TYPEDDICT_TYPES",
        "_TYPEVARTUPLE_TYPES",
        "_TypeFormForm",
        "_TypeVarLikeMeta",
        "_TypedDict",
        "_TypedDictMeta",
        "_TypedDictSpecialForm",
        "_UNPACK_DOC",
        "__all__",
        "__builtins__",
        "__cached__",
        "__doc__",
        "__file__",
        "__loader__",
        "__name__",
        "__package__",
        "__spec__",
        "_caller",
        "_check_generic",
        "_collect_parameters",
        "_concatenate_getitem",
        "_create_concatenate_alias",
        "_create_typeddict",
        "_get_protocol_attrs",
        "_get_typeddict_qualifiers",
        "_has_generic_or_protocol_as_origin",
        "_is_param_expr",
        "_is_unpack",
        "_is_unpacked_typevartuple",
        "_marker",
        "_overload_dummy",
        "_set_default",
        "_set_module",
        "_should_collect_from_parameters",
        "_types",
        "_typing_names",
        "_unpack_args",
        "abc",
        "annotationlib",
        "assert_never",
        "assert_type",
        "builtins",
        "cast",
        "clear_overloads",
        "collections",
        "contextlib",
        "dataclass_transform",
        "deprecated",
        "disjoint_base",
        "enum",
        "evaluate_forward_ref",
        "final",
        "functools",
        "get_annotations",
        "get_args",
        "get_origin",
        "get_original_bases",
        "get_overloads",
        "get_protocol_members",
        "get_type_hints",
        "inspect",
        "io",
        "is_protocol",
        "is_typeddict",
        "keyword",
        "no_type_check",
        "no_type_check_decorator",
        "operator",
        "overload",
        "override",
        "reveal_type",
        "runtime",
        "runtime_checkable",
        "sys",
        "type_repr",
        "typing",
        "warnings",
    )
    allcontents = typingcontents + typingextensionscontents
    ##
    _typing = __import__(name="typing")
    _typing_extensions = __import__(name="typing_extensions")
    for oneelem in allcontents:
        if oneelem in dir(_typing):
            globals()[oneelem] = getattr(_typing, oneelem)
        elif oneelem in dir(_typing_extensions):
            globals()[oneelem] = getattr(_typing_extensions, oneelem)
        else:
            continue
        __all__.append(oneelem)
else:

    def importallfromtypingandtypingextensions() -> None:
        # This function is used to import all attributes from typing
        # and typing_extensions into the global namespace of the caller.
        # use instead of
        # from typing import *  # type: ignore # noqa
        # from typing_extensions import *  # type: ignore # noqa
        _typing = __import__(name="typing")
        _typing_extensions = __import__(name="typing_extensions")
        global __all__
        for singleattr in [item for item in dir(_typing) if not item.startswith("_")]:
            # print(singleattr)
            sys._getframe(1).f_globals[singleattr] = getattr(
                __import__(name="typing"),
                singleattr,
            )
            __all__.append(singleattr)
        #    for singleattr in [item for item in dir(_typing_extensions) if item not in dir(_typing)]:
        for singleattr in [
            item
            for item in dir(_typing_extensions)
            if item not in dir(_typing) and not item.startswith("_")
        ]:
            # print(singleattr)
            sys._getframe(1).f_globals[singleattr] = getattr(
                __import__(name="typing_extensions"),
                singleattr,
            )
            __all__.append(singleattr)

    importallfromtypingandtypingextensions()
 """
